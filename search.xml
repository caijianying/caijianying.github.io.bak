<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 搭建博客框架</title>
    <url>/posts/eb92c116/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/">官网</a><br>1.安装nodeJs，查看版本<code>node --version</code>，Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本<br>2.安装git<br>3.安装Hexo</p>
<p>安装Hexo1.安装命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>这时博客就在本地生成了。访问<code>http://localhost:4000</code> 可以看效果。<br>可以说Hexo是很强大的，默认主题网站结构合理，适配手机，搜索栏（google）也有了。只需要优化（改一下失效的链接，添加评论，RSS等模块）就行了。<br>2.基本操作</p>
<ul>
<li><code>hexo g</code> 生成/public 文件夹，里面是网站</li>
<li><code>hexo d</code> 把这个网站文件夹推送到服务器</li>
<li><code>hexo clean</code> 删除网站文件夹</li>
<li><code>hexo s</code> 本地查看效果</li>
</ul>
<p>3.<a href="https://hexo.io/docs/one-command-deployment">Hexo官网一键部署</a><br>找到<code>_config.yml</code>文件编辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; # https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>
<p>使用<code>hexo deploy</code>部署</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world!</title>
    <url>/posts/3b4c26d/</url>
    <content><![CDATA[<p>1.在github 注册<br>2.创建一个公共的仓库 名称设置为<code>caijianying.github.io</code><br>3.点击settings<br><img src="/images/hw/1.png"><br>4.下拉到github Pages,选择分支、文件夹，save!<br><img src="/images/hw/2.png"><br>5.根据<a href="https://pages.github.com/">官网教程</a>操作，访问<code>https://caijianying.github.io</code>可以看到hello world</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF发票OCR识别</title>
    <url>/posts/4a4871b6/</url>
    <content><![CDATA[<h4 id="PDF发票OCR识别"><a href="#PDF发票OCR识别" class="headerlink" title="PDF发票OCR识别"></a>PDF发票OCR识别</h4><blockquote>
<p>基本解析过程是解析发票中的二维码，解析出发票的5要素：发票号码、发票代码、发票金额、开票日期、校验码</p>
</blockquote>
<h5 id="引入maven"><a href="#引入maven" class="headerlink" title="引入maven"></a>引入maven</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pdf发票解析--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pdfbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--现在项目一般都放这个包 视情况而定 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="解析pdf的完整代码"><a href="#解析pdf的完整代码" class="headerlink" title="解析pdf的完整代码"></a>解析pdf的完整代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取电子发票pdf文件中的发票信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pdfFile 电子发票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 发票信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InvoiceInfo <span class="title">getInvoiceInfo</span><span class="params">(File pdfFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;BufferedImage&gt; imageList = extractImage(pdfFile);</span><br><span class="line">        <span class="keyword">if</span> (imageList.isEmpty()) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;pdf中未解析出图片，返回空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultiFormatReader formatReader = <span class="keyword">new</span> MultiFormatReader();</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//正常解析出来有3张图片，第一张是二维码，其他两张图片是发票上盖的章</span></span><br><span class="line">        BinaryBitmap binaryBitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(<span class="keyword">new</span> BufferedImageLuminanceSource(imageList.get(<span class="number">0</span>))));</span><br><span class="line">        Map hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        result = formatReader.decode(binaryBitmap);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || StringUtils.isEmpty(result.getText())) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;pdf中的第一张图片没有解析了字符串信息，直接返回空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;从电子发票中识别出的信息为：&#123;&#125;&quot;</span>, result == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : result.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取到的信息为 ： 01，发票类型，发票代码，发票号码，发票金额，开票日期，校验码，随机产生的摘要信息</span></span><br><span class="line">        String[] infos = result.getText().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (infos.length != <span class="number">8</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;pdf中的第一张图片解析出的字符串数组长度不为8，返回空。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InvoiceInfo invoice = <span class="keyword">new</span> InvoiceInfo();</span><br><span class="line">        invoice.setInvoiceType(Integer.parseInt(infos[<span class="number">1</span>])); <span class="comment">//发票类型</span></span><br><span class="line">        invoice.setInvoiceCode(infos[<span class="number">2</span>]); <span class="comment">//发票代码</span></span><br><span class="line">        invoice.setInvoiceNo(infos[<span class="number">3</span>]); <span class="comment">// 发票号码</span></span><br><span class="line">        invoice.setTotalAmount(<span class="keyword">new</span> BigDecimal(infos[<span class="number">4</span>])); <span class="comment">// 发票金额</span></span><br><span class="line">        invoice.setInvoiceDate(infos[<span class="number">5</span>]); <span class="comment">//开票日期</span></span><br><span class="line">        invoice.setInvoiceCheckcode(infos[<span class="number">6</span>]); <span class="comment">// 校验码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoice;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析pdf中的二维码出现异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提取电子发票里面的图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pdfFile 电子发票文件对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> pdf中解析出的图片列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;BufferedImage&gt; <span class="title">extractImage</span><span class="params">(File pdfFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;BufferedImage&gt; imageList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    PDDocument document = PDDocument.load(pdfFile);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PDPage page = document.getPage(<span class="number">0</span>); <span class="comment">//电子发票只有一页</span></span><br><span class="line">        PDResources resources = page.getResources();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (COSName name : resources.getXObjectNames()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resources.isImageXObject(name)) &#123;</span><br><span class="line">                PDImageXObject obj = (PDImageXObject) resources.getXObject(name);</span><br><span class="line">                imageList.add(obj.getImage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        document.close();<span class="comment">//流未关闭会导致文件删除不掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h5><blockquote>
<p>考虑到本地文件、文件链接和字节流的情况。生成file对象的方法由3种。</p>
</blockquote>
<h6 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h6><blockquote>
<p>这种情况是最简单的。<code>File file = new File(filePath);</code></p>
</blockquote>
<h6 id="http连接"><a href="#http连接" class="headerlink" title="http连接"></a>http连接</h6><blockquote>
<p>需要把链接转化成inputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String remotePdf = <span class="string">&quot;http://XXXXX/rB4r9WBZqmaAeuXVAADICoWEwVQ508.PDF&quot;</span>;</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">File file = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file = TempFile.createTempFile(<span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(remotePdf);</span><br><span class="line">    is = url.openStream();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    InvoiceInfo invoiceInfo = getInvoiceInfo(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h6><blockquote>
<p>需要把链接转化成inputStream，其他部分跟http连接的处理方式一样，创建临时文件和关闭流。</p>
<p><code>InputStream is = new ByteArrayInputStream(download)</code></p>
</blockquote>
]]></content>
      <categories>
        <category>OCR识别</category>
      </categories>
      <tags>
        <tag>OCR识别</tag>
      </tags>
  </entry>
  <entry>
    <title>StampedLock</title>
    <url>/posts/ab957bc5/</url>
    <content><![CDATA[<h5 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h5><blockquote>
<p>ReentrantReadWriteLock 和 StampedLock完成的功能相似，但是StampedLock相比ReentrantReadWriteLock 提升了程序的性能和吞吐量。改进的点在于</p>
<ul>
<li><p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取(Pessimistic Reading)，即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿(Starvation)问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。</p>
<p>而 StampedLock的乐观读锁则解决了这一问题，<strong>乐观读锁认为读的时候是不会有写锁产生的</strong></p>
</li>
</ul>
</blockquote>
<span id="more"></span>

<h5 id="官网定义"><a href="#官网定义" class="headerlink" title="官网定义"></a>官网定义</h5><blockquote>
<p>整体来说，StampedLock用三种模式来控制读写的访问(<strong>写、读、乐观读</strong>),锁的状态由版本和模式确定。锁获取方法会返回一个stamp,返回为0表示执行失败。<br>锁的释放和转换会把stamp作为参数，如果它的值与状态不匹配则返回0表示失败！</p>
</blockquote>
<h5 id="Javadoc例"><a href="#Javadoc例" class="headerlink" title="Javadoc例"></a>Javadoc例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//写锁</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面看看乐观读锁案例 乐观读锁认为读的时候是不会有写锁产生的</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y; <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生?</span></span><br><span class="line">                stamp = sl.readLock(); <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁 这里锁升级了！</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY; <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp); <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock(); <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="写锁例子"><a href="#写锁例子" class="headerlink" title="写锁例子"></a>写锁例子</h6><p><code>writeLock()</code>：获取写锁，如果加锁失败会一直获取直到能获取到为止，返回一个<code>stamp</code>，有可能会阻塞。使用<code>unlockWrite(long)</code>来释放锁。<code>tryWriteLock()</code>也是获取写锁，但获取失败会返回stamp=0.对应释放锁方法<code>tryUnlockWrite()</code>.此方法用于异常的恢复。</p>
<h6 id="乐观读例子"><a href="#乐观读例子" class="headerlink" title="乐观读例子"></a>乐观读例子</h6><p>根据<code>tryOptimisticRead()</code>方法的注释</p>
<p><code>Returns a stamp that can later be validated, or zero if exclusively locked.</code></p>
<p>可以知道，</p>
<blockquote>
<p>如果排他锁即写锁存在，返回的stamp为0  <strong>乐观读锁认为读的时候是不会有写锁产生的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryOptimisticRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;写锁被占用后： &quot;</span>+sl.tryOptimisticRead());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">2</span>);<span class="comment">//为了保证锁释放前被另一个线程调用</span></span><br><span class="line">     sl.unlockWrite(stamp);</span><br><span class="line"></span><br><span class="line">     stamp = sl.readLock();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;读锁被占用后： &quot;</span>+sl.tryOptimisticRead());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">     sl.unlockRead(stamp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>调用结果</p>
<blockquote>
<p>写锁被占用后： 0<br>读锁被占用后： 512</p>
</blockquote>
<p>获取乐观读锁的方法一般与<code>validate</code>方法一起使用，有以下三种情况</p>
<ul>
<li><p><code>Returns true if the lock has not been exclusively acquired since issuance of the given stamp.</code> 锁没被占用，即没有线程去加锁，则返回true</p>
</li>
<li><p><code>Always returns false if the  stamp is zero.</code></p>
<p>stamp为0（一般表示尝试加锁失败）返回false</p>
</li>
<li><p><code>Always returns true if the stamp represents a currently held lock.</code></p>
<p>当前线程持有锁，返回true</p>
</li>
<li><p><code>Invoking this method with a value not obtained from &#123;@link #tryOptimisticRead&#125; or a locking method for this lock has no defined effect or result.</code></p>
<p>stamp 不是从<code>tryOptimisticRead()</code>或者加锁方法中得到的，则没有意义，返回false。</p>
</li>
</ul>
</blockquote>
<p>进入获取乐观读锁的方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> s;</span><br><span class="line">        <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    U.loadFence();</span><br><span class="line">    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了内存读屏障<code>U.loadFence()</code>，严格保证了该方法之前的所有load操作在内存屏障之前完成。</p>
<h6 id="读锁例子"><a href="#读锁例子" class="headerlink" title="读锁例子"></a>读锁例子</h6><p><code>readLock()</code>：获取读锁，同样可能会造成阻塞，返回一个stamp.对应释放锁方法为<code>unlockRead(long)</code>。也有<code>tryReadLock</code>和<code>tryUnlockRead</code>方法，通常也是用于异常后的恢复。基本思想是，先加一个读锁，判断数据有没有被修改，没被修改则将读锁转为写锁，转为写锁成功则修改数据，否则释放读锁资源，再次获取写锁，直到获取成功为止。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol>
<li> <a href="https://www.pdai.tech/md/java/java8/java8-stampedlock.html">stampedlock解析</a></li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
        <category>StampedLock</category>
      </categories>
      <tags>
        <tag>StampedLock</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据简图</title>
    <url>/posts/fee3ab36/</url>
    <content><![CDATA[<p>学习路线</p>
<p><img src="https://www.caijy.top//image-20210626155255769.png" alt="image-20210626155255769"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>高效工具分享</title>
    <url>/posts/122b4e9d/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><blockquote>
<p>分享一些 <code>chrome</code> 脚本, 及创建教程,<br>利用操作系统的搜索引擎, 可以快速打开你经常去的网站<br>同理, 你也可以用此方法, 去简化更多事情</p>
</blockquote>
<h1 id="2-演示"><a href="#2-演示" class="headerlink" title="2. 演示"></a>2. 演示</h1><p><img src="https://www.caijy.top//2021-07-01%2015.40.29.gif" alt="2021-07-01 15.40.29.gif"></p>
<span id="more"></span>

<h1 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h1><h2 id="3-1-使用-shell-带的-open-a-命令"><a href="#3-1-使用-shell-带的-open-a-命令" class="headerlink" title="3.1 使用 shell 带的 open -a 命令"></a>3.1 使用 <code>shell</code> 带的 <code>open -a</code> 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open -a /Applications/Google\ Chrome.app https://www.bilibili.com/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释:</p>
<p><code>open -a</code> 打开指定的 app<br><code>Google\ Chrome.app</code><br>chrome 名字有空格, \ 避免空格, 同时也可以加引号使用 <code>open -a &quot;Google Chrome.app&quot;</code><br>app 后面跟 网站地址, 即可</p>
</blockquote>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.13.45.png" alt="截屏2021-07-11 下午12.13.45" style="zoom:50%;">

<h2 id="3-2-使用-chrome-自带命令"><a href="#3-2-使用-chrome-自带命令" class="headerlink" title="3.2 使用 chrome 自带命令"></a>3.2 使用 chrome 自带命令</h2><blockquote>
<p><code>/Applications/Google Chrome.app/Contents/MacOS</code> 文件夹下有一个 <code>Google Chrome</code><br>这是一个可执行文件, 它也可以直接打开指定网站, 也有一些参数可以使用<br>具体看下面</p>
</blockquote>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.19.36.png" alt="截屏2021-07-11 下午12.19.36" style="zoom:50%;">

<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.20.22.png" alt="截屏2021-07-11 下午12.20.22" style="zoom:50%;">


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接打开网站, 如果此时已有 chrome 窗口, 则以 tag 形式加入</span></span><br><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新窗口打开网站</span></span><br><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --new-window https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无痕模式打开网站, 如果此时已有 chrome 无痕窗口, 则以 tag 形式加入</span></span><br><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --incognito https://www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新窗口, 无痕模式打开网站</span></span><br><span class="line">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --new-window --incognito https://www.baidu.com</span><br></pre></td></tr></table></figure>


<h1 id="4-脚本文件创建"><a href="#4-脚本文件创建" class="headerlink" title="4. 脚本文件创建"></a>4. 脚本文件创建</h1><ul>
<li>创建一个文件, 以 <code>.sh</code> 结尾</li>
<li>右键文件 –&gt; 显示简介 –&gt; 打开方式 –&gt; 选择 **终端 **(相当于默认打开软件的设置)</li>
<li>然后命令行给予该文件可执行权限, 也可以给该文件夹下所有的文件可执行权限</li>
<li>command + space 聚焦搜索 该文件, 打开即可</li>
</ul>
<blockquote>
<p>文件创建, 打开方式</p>
</blockquote>
<blockquote>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.24.37.png" alt="截屏2021-07-11 下午12.24.37" style="zoom:50%;">
</blockquote>
<blockquote>
<p>可执行权限</p>
</blockquote>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.26.34.png" alt="截屏2021-07-11 下午12.26.34" style="zoom:50%;">


<h1 id="5-脚本分享"><a href="#5-脚本分享" class="headerlink" title="5. 脚本分享"></a>5. 脚本分享</h1><ul>
<li>谷歌翻译<ul>
<li>```java<br>open -a /Applications/Google\ Chrome.app <a href="https://translate.google.cn/">https://translate.google.cn/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 有道词典</span><br><span class="line">   - &#96;&#96;&#96;java</span><br><span class="line">     open -a &#x2F;Applications&#x2F;Google\ Chrome.app https:&#x2F;&#x2F;www.youdao.com&#x2F;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>百度地图<ul>
<li><pre><code>open -a /Applications/Google\ Chrome.app https://www.youdao.com/
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">json 解析工具网站</span><br><span class="line"></span><br></pre></td></tr></table></figure>
open -a /Applications/Google\ Chrome.app https://www.bejson.com/
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="7-alfred"><a href="#7-alfred" class="headerlink" title="7. alfred"></a>7. alfred</h1><blockquote>
<p>使用alfred可以达到同样的效果，并且不需要脚本配置</p>
</blockquote>
<h4 id="参考alfred配置，看-Web-Search部分即可。"><a href="#参考alfred配置，看-Web-Search部分即可。" class="headerlink" title="参考alfred配置，看 Web Search部分即可。"></a><a href="https://www.jianshu.com/p/e9f3352c785f">参考alfred配置</a>，看 Web Search部分即可。</h4>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/posts/66c016fb/</url>
    <content><![CDATA[<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><img src="http://www.caijy.top/image-20210318221702882.png" alt="image-20210318221702882" style="zoom: 80%;">

<h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><h1 id><a href="#" class="headerlink" title></a><img src="http://www.caijy.top/image-20210321125505092.png" alt="image-20210321125505092"></h1><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><blockquote>
<p>程序计数器，可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<ol>
<li><p>为什么说程序计数器是线程私有的？</p>
<blockquote>
<p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p>
</blockquote>
</li>
<li><p>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong>本地（Native）方法</strong>，这个计数器值则应为空（Undefined）。</p>
</li>
</ol>
</blockquote>
<span id="more"></span>

<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><blockquote>
<ul>
<li>虚拟机栈描述的是Java方法执行的线程内存模型: 每个方法被执行的时候，JAVA虚拟机都会创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。<strong>方法从调用到执行结束，对应着栈帧在虚拟机栈中入栈到出栈的过程</strong>。</li>
<li>注意： </li>
</ul>
<blockquote>
<p>栈申请内存失败，会出现OutOfMemoryError异常</p>
</blockquote>
<p>HotSpot虚拟机的栈容量是不可以动态扩展的。只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。</p>
<blockquote>
<p>线程请求的栈深度大于虚拟机允许的深度，会出现StackOverflowError异常</p>
</blockquote>
</blockquote>
<h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><blockquote>
<ul>
<li><p>局部变量表存放的是<strong>基本数据类型</strong>、<strong>对象引用</strong>(它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）。</p>
</li>
<li><p>局部变量表由<strong>局部变量槽</strong>组成，除了64位<strong>long和double</strong>类型的数据会占用<strong>两个变量槽</strong>外，其余的数据类型只占用一个。局部变量表所需的内存空间，在程序编译期间就已完成分配。</p>
</li>
</ul>
</blockquote>
<h6 id="操作数栈（Operand-Stacks）"><a href="#操作数栈（Operand-Stacks）" class="headerlink" title="操作数栈（Operand Stacks）"></a>操作数栈（Operand Stacks）</h6><blockquote>
<p>每个栈帧都包含一个后进先出的操作数栈。当栈帧被创建时，一个空的操作数栈就被创建了。操作数栈会使用指令将局部变量表的常量或值加载进来。</p>
</blockquote>
<h6 id="动态连接-Dynamic-Linking"><a href="#动态连接-Dynamic-Linking" class="headerlink" title="动态连接(Dynamic Linking)"></a>动态连接(Dynamic Linking)</h6><blockquote>
<ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。 包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking）。比如: invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（ symbolic Reference）保存在class文件的常量池里。 比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将<strong>这些符号引用转换为调用方法的直接引用</strong>。</li>
</ul>
</blockquote>
<h6 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h6><blockquote>
<ul>
<li>当一个方法开始执行后，只有两种方式可以退出这个方法。方法退出的时候相当于当前栈帧出栈。<ul>
<li>第一种是JVM碰到任意一个方法返回的字节码指令，被称为正常完成出口。</li>
<li>另一种是在执行方法中抛出异常并且未对异常进行处理，被称为异常完成出口。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><blockquote>
<p>本地方法栈为虚拟机使用到的本地(Native)方法服务。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
</blockquote>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><blockquote>
<p>The heap is the runtime data area from which memory for all class instances and arrays is allocated。</p>
</blockquote>
<p>《Java虚拟机规范》原文的意思是”所有的对象实例以及数组都应当在堆上分配。”但是随着现在编译技术的进步，HotSpot使用了<strong>逃逸分析</strong>技术，出现了<strong>栈上分配、标量替换</strong>等优化手段（大致意思就是说，HotSpot虚拟机会先判断对象是否发生逃逸，如果未发生逃逸，则对对象进行栈上分配和标量替换），这使得这句话不再这么绝对了。现在的垃圾回收器也不一定是分代垃圾回收器了，HotSpot也出现了不采用分代设计的新垃圾收集器。从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的<strong>分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><blockquote>
<p>It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods  used in class and instance initialization and interface initialization</p>
<p>《Java虚拟机规范》提到方法区存储的是运行时常量池，类的属性字段及方法，构造方法的缓存代码包括类和接口初始化的方法。</p>
<p>《深入理解JAVA虚拟机》提到”它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。”</p>
<ul>
<li><p>java6之前，常量、静态变量、类元信息存储在永久代中，到了jdk6，HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了。到了jdk7，原本放在永久代的字符串常量池和静态变量就被移出，到了jdk8才完全废弃了永久代的概念，永久代剩余的内容(类型信息)全部移到用本地内存实现的元空间中。</p>
</li>
<li><p>总之，只要记住：方法区是由本地内存实现的，它存储的主要是运行时常量池、静态变量和类型信息。元空间是方法区的一部分，存储的主要是类型信息。</p>
</li>
<li><p>那么疑问出现了，openjdk官网提到”The proposed implementation will allocate class meta-data in native memory and move interned Strings and class statics to the Java heap.”意思是说，字符串常量和类静态数据都放到了java堆中。其实可以说，字符串常量和静态变量放在方法区。因为《Java虚拟机规范》把方法区描述为，逻辑上为堆的一部分。不过既然有了方法区这个概念把堆区分开来，那么说字符串常量和类静态数据都放到了方法区中，也是对的。</p>
<ul>
<li> 运行时常量池 </li>
</ul>
<blockquote>
<p>对于运行时常量池，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。典型的例子就是 String类的intern()方法，下面是示例。</p>
<ol>
<li>直接用双引号声明出来的 String对象 会直接分配在存储在字符串常量池里面。，<code>&quot;&quot; </code>就相当于<code> &quot;&quot;.intern();</code></li>
<li>如果不是用双引号声明的 String对象，可以调用String对象的intern方法。intern方法会检查字符串常量池里面是否存在当前字符串，如果不存在就会把该字符串存储在常量池里，存在则直接返回该字符串的引用。</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 常量池中的串池StringTable[],是一个哈希表</span></span><br><span class="line"><span class="comment"> * String intern的插入逻辑：先判断是否这个值 没有的话就插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;ab&quot;</span>;<span class="comment">//StringTable  [&quot;ab&quot;]</span></span><br><span class="line">        String ab = <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;<span class="comment">//本质是使用StringBuilder拼接，此时串池中已有ab 直接引用</span></span><br><span class="line">        System.out.println(a == ab);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//执行后 s会被放入堆中</span></span><br><span class="line">        String intern = s.intern();<span class="comment">//串池中为 [&quot;ab&quot;],没有&quot;1&quot;所以需要加入串池。执行完 [&quot;ab&quot;,&quot;1&quot;]</span></span><br><span class="line">        String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">// false s在堆中 s2引用的是串池中的值 不相等</span></span><br><span class="line">        System.out.println(intern == s2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;X&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;Y&quot;</span>);<span class="comment">//执行完 s3会放入堆中</span></span><br><span class="line">        s3.intern();<span class="comment">//StringTable中没有&quot;XY&quot;，插入后为  [&quot;ab&quot;,&quot;1&quot;,&quot;XY&quot;]</span></span><br><span class="line">        String s4 = <span class="string">&quot;XY&quot;</span>;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><h6 id="-1"><a href="#-1" class="headerlink" title></a></h6>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal不简单</title>
    <url>/posts/a653477f/</url>
    <content><![CDATA[<h5 id="弱引用介绍"><a href="#弱引用介绍" class="headerlink" title="弱引用介绍"></a>弱引用介绍</h5><blockquote>
<p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</blockquote>
<p>周志明书中提到了弱引用的概念，其中最典型的是ThreadLocal的例子。下面我们来探究。</p>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><ul>
<li>这是官方JDK对ThreadLocal类的解释。</li>
</ul>
<blockquote>
<p>This class provides thread-local variables.  These variables differ from<br>their normal counterparts in that each thread that accesses one (via its<br>{@code get} or {@code set} method) has its own, independently initialized<br>copy of the variable.  {@code ThreadLocal} instances are typically private<br>static fields in classes that wish to associate state with a thread (e.g.,<br>a user ID or Transaction ID).</p>
</blockquote>
<p>​    大致意思就是说，这个类会为每个线程提供一个本地变量，通过set和get方法设置和获取。每个线程只能修改本线程的那个值。</p>
<span id="more"></span>

<h5 id="ThreadLocal的set"><a href="#ThreadLocal的set" class="headerlink" title="ThreadLocal的set"></a>ThreadLocal的set</h5><ul>
<li><p>接下来我们来看set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal接收到value，转手就交给了<strong>ThreadLocalMap</strong>。ThreadLocal初始化的时候，会走<code>createMap</code>这个方法，初始化一个容量为16的Entry数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//... ... 省略部分代码</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这里ThreadLocal已经初始化完毕，看<code>map.set(this, value);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">           <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">           <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">           <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">           <span class="comment">// path would fail more often than not.</span></span><br><span class="line">  </span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line">           <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">           <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">  </span><br><span class="line">               <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">  </span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   replaceStaleEntry(key, value, i);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">           <span class="keyword">int</span> sz = ++size;</span><br><span class="line">           <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">               rehash();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>最后核心代码是<code> tab[i] = new Entry(key, value);</code> 我们来看这个entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这个Entry继承了一个弱引用，我们传入的k(即<code>this</code>)被<code>super(k);</code>调用。我们跟进到<code>WeakReference</code>的<strong>顶级父类</strong><code>Reference</code>，k这个强引用就被关联上了。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">       <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">       <span class="keyword">this</span>.referent = referent;</span><br><span class="line">       <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这说明ThreadLocal类的引用链是：entry的key(弱引用)指向了强引用，那么垃圾回收的时候就不会回收这个entry中的key。执行结果也确实说明没有被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">local.set(<span class="number">10</span>);</span><br><span class="line">System.out.println(local.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(local.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果： </span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>那么疑问就来了，ThreadLocal使用不当是会造成内存泄露的，在使用完后需要手动去关闭这个ThreadLocal的使用，正确姿势是<code>local.remove();</code>我们使用<code>local.remove();</code>代替<code>System.gc();</code>。执行结果说明，remove方法并不是只是单纯做了一个GC操作，那么remove是怎么实现垃圾回收的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">local.set(<span class="number">10</span>);</span><br><span class="line">System.out.println(local.get());</span><br><span class="line">local.remove();</span><br><span class="line">System.out.println(local.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="ThreadLocal的remove"><a href="#ThreadLocal的remove" class="headerlink" title="ThreadLocal的remove"></a>ThreadLocal的remove</h5>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>  主要把remove方法交给了ThreadLocalMap去做，继续跟进到ThreadLocalMap的remove。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>  <code>e.clear();</code>是核心，调用了<strong>顶级父类</strong><code>Reference</code>删除了Entry中的key。这段代码切断了这条引用链，删除了强引用的关联，导致虚引用此时无法跟强引用建立关联，这样的话垃圾回收器会直接回收。内部实现很简单。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>  接下来我们看这段代码就能看懂了。</p>
<blockquote>
<p>这里直接调用垃圾回收器回收是回收不掉的，因为弱引用与强引用<strong>1</strong>建立了关联。</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Integer&gt; reference = <span class="keyword">new</span> WeakReference&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">System.out.println(reference.get());</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(reference.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  调用结果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来我们使用<code>reference.clear();</code>把引用删除，弱引用立马就被回收了。</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Integer&gt; reference = <span class="keyword">new</span> WeakReference&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">System.out.println(reference.get());</span><br><span class="line">reference.clear();</span><br><span class="line">System.out.println(reference.get());</span><br></pre></td></tr></table></figure>

<p>  调用结果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>ThreadLocal与弱引用</tag>
      </tags>
  </entry>
  <entry>
    <title>Jclasslib分析字节码</title>
    <url>/posts/9f29f421/</url>
    <content><![CDATA[<h4 id="下载及使用"><a href="#下载及使用" class="headerlink" title="下载及使用"></a>下载及使用</h4><pre><code>1. 搜索  &quot;jclasslib Bytecode viewer &quot;下载插件，并重启IDEA
2. IDEA   view -&gt; show Bytecode With Jclasslib
</code></pre>
<h4 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">int</span> c = sum(a,b);</span><br><span class="line">      System.out.println(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> args1, <span class="keyword">int</span> args2)</span> </span>&#123;</span><br><span class="line">      Lists.newArrayList().forEach((t)-&gt; System.out.println(t));<span class="comment">//为了能看到动态连接的指令</span></span><br><span class="line">      <span class="keyword">return</span> args1 + args2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="首先会将当前这个实例放入局部变量表"><a href="#首先会将当前这个实例放入局部变量表" class="headerlink" title="首先会将当前这个实例放入局部变量表"></a>首先会将当前这个实例放入局部变量表</h5><h5 id><a href="#" class="headerlink" title></a><img src="http://www.caijy.top/image-20210323224206973.png" style="zoom: 50%;"></h5><h5 id="解析字节码"><a href="#解析字节码" class="headerlink" title="解析字节码"></a>解析字节码</h5><p>注意：这里说的栈是指<strong>操作数栈</strong>。</p>
<h6 id="test02的字节码"><a href="#test02的字节码" class="headerlink" title="test02的字节码"></a><code>test02</code>的字节码</h6><ul>
<li><blockquote>
<p>0 bipush 10    //将常量10推送至栈顶<br>2 istore_1       // 将int类型数值(10)存入局部变量表<br>3 bipush 20   //将常量20推送至栈顶<br>5 istore_2      // 将int类型数值(20)存入局部变量表<br>6 aload_0      // 将第一个引用类型变量（this）推送至栈顶<br>7 iload_1      // 将第二个int 型本地变量(a)推送至栈顶<br>8 iload_2      // 将第二个int 型本地变量(b)推送至栈顶<br>9 invokespecial #2 &lt;Test2.sum&gt;  //调用超类构造方法，实例初始化方法，私有方法<br>12 istore_3   // 将int类型数值(30)存入局部变量表<br>13 getstatic #3 &lt;java/lang/System.out&gt;<br>16 iload_3<br>17 invokevirtual #4 &lt;java/io/PrintStream.println&gt;<br>20 return  //当前方法返回void</p>
</blockquote>
</li>
</ul>
<h6 id="sum的字节码"><a href="#sum的字节码" class="headerlink" title="sum的字节码 `"></a><code>sum</code>的字节码 `</h6><ul>
<li><blockquote>
<p>0 invokestatic #5 &lt;org/assertj/core/util/Lists.newArrayList&gt;<br>3 invokedynamic #6 &lt;accept, BootstrapMethods #0&gt;   //<strong>java8的lambda表达式 成为了 动态连接指令invokedynamic 的生成方式</strong><br>8 invokevirtual #7 &lt;java/util/ArrayList.forEach&gt;<br>11 iload_1<br>12 iload_2<br>13 iadd     //将栈顶2个int类型的值相加并将结果压入栈顶<br>14 ireturn    //当前方法返回int</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
        <category>分析字节码</category>
      </categories>
      <tags>
        <tag>JVM字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>mac工具箱</title>
    <url>/posts/40c6ad79/</url>
    <content><![CDATA[<p><a href="https://www.yuque.com/jianying-8bux1/mt5ny0/ic6tqk">传送门</a></p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM中的对象</title>
    <url>/posts/1e06d641/</url>
    <content><![CDATA[<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><blockquote>
<p>我们平常创建对象是通过new关键词来创建的。下面来探索一个对象到底经历了那几个步骤才能被创建。</p>
</blockquote>
<h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><blockquote>
<p>编译期间，JVM会进行类加载的过程，将生成的各种字面量与符号引用，存放到方法区的运行时常量池中。所以，当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。</p>
</blockquote>
<span id="more"></span>

<h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><h5 id="如何划分可用空间"><a href="#如何划分可用空间" class="headerlink" title="如何划分可用空间"></a>如何划分可用空间</h5><blockquote>
<p>对象所需内存的大小在类加载时就已确定，而根据Java堆是否规整分为2种分配方式</p>
<ol>
<li><strong>指针碰撞 ，针对Java堆绝对规整的情况</strong>。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离。</li>
<li><strong>空闲列表(Free List) ，Java堆不是绝对规整的情况</strong>。如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，</li>
</ol>
<blockquote>
<p>总结</p>
<p>当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p>
</blockquote>
</blockquote>
<h5 id="如何保证并发情况下的线程安全"><a href="#如何保证并发情况下的线程安全" class="headerlink" title="如何保证并发情况下的线程安全"></a>如何保证并发情况下的线程安全</h5><blockquote>
<p>因为可能会出现，即使仅仅修改一个指针所指向的位置，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。所以JVM使用了TLAB，本地线程分配缓冲，即把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。    </p>
</blockquote>
<h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><blockquote>
<p>主要是类指针、hashcode、GC的分代年龄、锁信息等等</p>
</blockquote>
<h4 id="执行-invokespecial"><a href="#执行-invokespecial" class="headerlink" title="执行 invokespecial"></a>执行 invokespecial</h4><blockquote>
<p>执行invokespecial其实就是调用class文件中的init方法，可以看作是一个构造函数。</p>
</blockquote>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><h4 id="JOL工具的使用"><a href="#JOL工具的使用" class="headerlink" title="JOL工具的使用"></a>JOL工具的使用</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="建一个User类"><a href="#建一个User类" class="headerlink" title="建一个User类"></a>建一个User类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">10</span>);</span><br><span class="line">log.info(ClassLayout.parseInstance(user).toPrintable());</span><br></pre></td></tr></table></figure>

<h5 id="打印如图"><a href="#打印如图" class="headerlink" title="打印如图"></a>打印如图</h5><img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-08-25%20%E4%B8%8B%E5%8D%8810.37.22.png" alt="截屏2021-08-25 下午10.37.22" style="zoom:50%;">

<h4 id="内存布局的划分-JMM"><a href="#内存布局的划分-JMM" class="headerlink" title="内存布局的划分(JMM)"></a>内存布局的划分(JMM)</h4><blockquote>
<p>可见一个对象在堆内存的存储布局被分为三个部分：<strong>对象头、实例数据和对齐填充</strong></p>
</blockquote>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><h6 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h6><blockquote>
<p><strong>Mark Word</strong>：用于存储对象自身的运行时数据，如哈 希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部 分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特</p>
</blockquote>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-08-25%20%E4%B8%8B%E5%8D%8810.45.34.png" alt="截屏2021-08-25 下午10.45.34" style="zoom:50%;">

<h6 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h6><blockquote>
<p>类型指针: 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例</p>
</blockquote>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><blockquote>
<p>对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。例如我们创建的User对象中的name和age字段。</p>
</blockquote>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><blockquote>
<p>这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>spring实例化bean的过程探索(下)</title>
    <url>/posts/7791370/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>在上篇已经知道Spring的bean是从单例池中取的，但是有两个问题依旧是个迷！<ul>
<li><ol>
<li>Spring的bean是如何被创建的？</li>
<li>创建好的bean是怎么被放进单例池的？</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><ul>
<li>由上篇可以推断出Spring容器在初始化的时候就已经创建好了bean，所以我们从第一次取出<code>testBean</code>为空的地方开始打断点，看看它接下来做了什么。下面开始探索。</li>
</ul>
<p><img src="https://www.caijy.top//spring%E5%88%9B%E5%BB%BAbean%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%952-1.gif" alt="spring创建bean源码调试1"></p>
<ul>
<li>录屏比较长，跟着调试会知道：Spring会从<code>beanDefinition</code>中推断出构造方法，通过构造方法new一个实例出来，核心代码段是<code>ctor.newInstance(args)</code>。接着会填充属性，执行了<code>addSingleton(beanName, singletonObject)</code>方法，将完整的bean保存在单例池中。</li>
</ul>
]]></content>
      <categories>
        <category>spring 5.1.X源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>编译spring 5.1.X源码</title>
    <url>/posts/c9117111/</url>
    <content><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol>
<li>mac环境</li>
<li>JDK 1.8.0_202</li>
<li>Gradle 4.10.3</li>
</ol>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h5 id="把spring源码fork到自己的仓库"><a href="#把spring源码fork到自己的仓库" class="headerlink" title="把spring源码fork到自己的仓库"></a>把spring源码fork到自己的仓库</h5><p><code>https://github.com/spring-projects/spring-framework</code></p>
<span id="more"></span>

<h5 id="下载spring源码"><a href="#下载spring源码" class="headerlink" title="下载spring源码"></a>下载spring源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git clone git<span class="meta">@github</span>.com:caijianying/spring-framework.git -b <span class="number">5.1</span>.x</span><br></pre></td></tr></table></figure>

<h5 id="确定gradle版本"><a href="#确定gradle版本" class="headerlink" title="确定gradle版本"></a>确定gradle版本</h5><p>进入<code>spring-framework</code>查看配置文件<code>cat gradle/wrapper/gradle-wrapper.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-4.10.3-bin.zip</span></span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure>

<p><code>distributionUrl</code>就是下载地址</p>
<h5 id="预编译前，修改build-gradle的镜像源"><a href="#预编译前，修改build-gradle的镜像源" class="headerlink" title="预编译前，修改build.gradle的镜像源"></a>预编译前，修改<code>build.gradle</code>的镜像源</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/spring-plugin&#x27;</span> &#125;</span><br><span class="line">    maven &#123; url <span class="string">&quot;https://repo.spring.io/libs-spring-framewrok-build&quot;</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dependencies &#123;</span><br><span class="line">		classpath(<span class="string">&quot;io.spring.gradle:propdeps-plugin:0.0.9.RELEASE&quot;</span>)</span><br><span class="line">		classpath(<span class="string">&quot;org.asciidoctor:asciidoctorj-pdf:1.5.0-alpha.16&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看import-into-idea-md"><a href="#查看import-into-idea-md" class="headerlink" title="查看import-into-idea.md"></a>查看<code>import-into-idea.md</code></h5><ol>
<li>Precompile <code>spring-oxm</code> with <code>./gradlew :spring-oxm:compileTestJava</code></li>
<li>Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</li>
<li>When prompted exclude the <code>spring-aspects</code> module (or after the import via File-&gt; Project Structure -&gt; Modules)</li>
<li>Code away</li>
</ol>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><h4 id="预编译过程中可能会出现JDK-tools无法被Kotlin找到的问题"><a href="#预编译过程中可能会出现JDK-tools无法被Kotlin找到的问题" class="headerlink" title="预编译过程中可能会出现JDK tools无法被Kotlin找到的问题"></a>预编译过程中可能会出现<code>JDK tools</code>无法被<code>Kotlin</code>找到的问题</h4><p><code>Kotlin could not find the required JDK tools in the Java installation &#39;/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home&#39; used by Gradle. Make sure Gradle is running on a JDK, not JRE.</code></p>
<ol>
<li><p>检查下当前的java环境 <code>/usr/libexec/java_home -V</code></p>
<p><img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-11%20%E4%B8%8B%E5%8D%8812.01.06.png" alt="截屏2021-07-11 下午12.01.06"></p>
<p>看到有两个JDK 路径，打开发现<code>/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</code>下的JDK确实没有jre，而通过dmg安装的<code>/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home</code>路径下有</p>
</li>
<li><p>在gradle.properties中配置org.gradle.java.home，指定gradle编译使用的java环境目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_202</span>.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line">#### Kotlin版本太低</span><br><span class="line"></span><br><span class="line">`Kotlin: API version <span class="number">1.1</span> is no longer supported; please, use version <span class="number">1.2</span> or greater.`</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 修改`build.gradle` 的`apiVersion` 和`languageVersion`</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   compileKotlin &#123;</span><br><span class="line">   		kotlinOptions &#123;</span><br><span class="line">   			jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">   			freeCompilerArgs = [<span class="string">&quot;-Xjsr305=strict&quot;</span>]</span><br><span class="line">   			apiVersion = <span class="string">&quot;1.2&quot;</span></span><br><span class="line">   			languageVersion = <span class="string">&quot;1.2&quot;</span></span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="运行单元测试，总是执行gradle打包命令"><a href="#运行单元测试，总是执行gradle打包命令" class="headerlink" title="运行单元测试，总是执行gradle打包命令"></a>运行单元测试，总是执行gradle打包命令</h4><p>这两处选择IDEA<img src="https://www.caijy.top//1.png" alt="1" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>spring 5.1.X源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的设置</title>
    <url>/posts/b48dde48/</url>
    <content><![CDATA[<h4 id="主题选好了，接下来要把这个demo变成我们自己的博客"><a href="#主题选好了，接下来要把这个demo变成我们自己的博客" class="headerlink" title="主题选好了，接下来要把这个demo变成我们自己的博客"></a>主题选好了，接下来要把这个demo变成我们自己的博客</h4><p>1.将根目录的<code>_config.yml</code>文件修改一下<br><img src="/images/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE/1.png"></p>
<span id="more"></span>
<p>2.找到<code>blog/node_modules/hexo-theme-next</code>复制它的<code>_config.yml</code>到博客根目录<br><code>cp .\node_modules\hexo-theme-next\_config.yml _config.next.yml</code><br>3.看<code>_config.next.yml</code>这个文件，改动点不多<br><img src="/images/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE/2.png"><br>设置菜单主题<br><img src="/images/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE/3.png"><br>设置菜单显示的内容和侧边栏的显示位置<br><img src="/images/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE/4.png"><br>设置头像<br>4.创建标签、分类、关于等页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>可以看到<code>source</code>文件夹下多了三个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2021-02-28 22:52:21</span><br><span class="line">tags:</span><br><span class="line">type: about</span><br><span class="line">comments: false</span><br><span class="line">sitemap: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>对应的是<code>about</code>文件夹的就改成about，其他2个也一样设置<br>5.添加搜索功能</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator</span><span class="literal">-searchdb</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>
<p>找到<code>_config.yml</code>文件的 Extensions下面添加</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>找到主题配置文件的Local search将<code>enable</code>设置为<code>true</code>6.添加阅读全文按钮只要在博客里面加上 <code>&lt;!--more--&gt;</code>就行7.设置分类<code>博客设置</code>和标签<code>博客</code>的方法</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 给博客选择主题</span><br><span class="line">date: <span class="number">2021</span><span class="literal">-02</span><span class="literal">-28</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">21</span></span><br><span class="line">categories: </span><br><span class="line">- 博客</span><br><span class="line">- 博客设置</span><br><span class="line">tags: 博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>8<a href="https://hexo.io/zh-cn/docs/asset-folders">图片加载配置</a></p>
<p>记录一下主题官网 <a href="http://theme-next.iissnan.com/getting-started.html">theme-next</a>为了方便写博客，推荐使用Hexo-admin 工具写md</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>访问<code>http://localhost:4000/admin</code>即可，看效果<br><img src="/images/%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE/5.png"></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客设置</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>spring核心过程</title>
    <url>/posts/dd678fc4/</url>
    <content><![CDATA[<p><img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-25%20%E4%B8%8B%E5%8D%889.26.04.png" alt="截屏2021-07-25 下午9.26.04"></p>
]]></content>
      <categories>
        <category>spring 5.1.X源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/posts/df9a61f7/</url>
    <content><![CDATA[<h4 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h4><blockquote>
<p>MYSQL官方的定义为：索引是帮助MYSQL高效获取数据的数据结构。索引是数据结构。</p>
<p>可以理解为，排好序的快速查找数据结构。</p>
</blockquote>
<h4 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><blockquote>
<p>提高数据检索效率 降低数据库IO成本(检索)</p>
<p>通过索引对数据排序，降低数据排序的成本，降低了CPU的消耗(排序)</p>
</blockquote>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><blockquote>
<p>索引列会占磁盘空间</p>
<p>会降低更新表的速度。因为更新表时，MYSQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段，更新索引信息。</p>
<p>如果有大数据量的表，需要花时间研究建立最合适的索引</p>
</blockquote>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><span id="more"></span>

<h5 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h5><blockquote>
<p>一个索引只包含单个列，一个表可以有多个单列索引</p>
</blockquote>
<h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><blockquote>
<p>索引列的值必须唯一，但允许有空值</p>
</blockquote>
<h5 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h5><blockquote>
<p>一个索引包含多个列</p>
</blockquote>
<h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><blockquote>
<ol>
<li><p>主键自动建立唯一索引</p>
</li>
<li><p>频繁作为查询条件的字段应该创建索引</p>
</li>
<li><p>与其他表关联的字段，外键关系要建立索引</p>
</li>
<li><p>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</p>
</li>
<li><p>查询中group by 或统计的字段</p>
</li>
</ol>
</blockquote>
<h4 id="哪些情况不需要建立索引"><a href="#哪些情况不需要建立索引" class="headerlink" title="哪些情况不需要建立索引"></a>哪些情况不需要建立索引</h4><blockquote>
<ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>如果某个数据列包含许多重复的内容且平均分布 为它建立索引就没太大的效果</li>
</ol>
</blockquote>
<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><p>查看执行计划，会显示如下几个字段</p>
<blockquote>
<p><img src="http://www.caijy.top/image-20210311211631332.png" alt="image-20210311211631332"></p>
</blockquote>
<p><strong>主要看type、key、ref、rows、Extra</strong></p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p><img src="http://www.caijy.top/image-20210311215626045.png" alt="image-20210311215626045"></p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><blockquote>
<p>可以查看是否用到了索引以及用到了什么索引</p>
</blockquote>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><blockquote>
<p>引用那一列索引</p>
</blockquote>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><blockquote>
<p>对应的表查询了多少行</p>
</blockquote>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><blockquote>
<p>避免 <strong>Using filesort</strong> ，MYSQL无法利用索引完成排序而进行额外的排序</p>
<p>避免 <strong>Using temporary</strong>  常见于order by、group by。MYSQL排序产生了临时表保存中间结果。</p>
</blockquote>
<h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><h5 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h5><blockquote>
<p>查看执行计划，<strong>Using filesort</strong> 说明mysql内部进行了一次额外排序，<strong>type=ALL</strong>说明也进行了全表扫描，需要避免。</p>
<p>为了优化 <strong>SELECT id,author_id FROM article where category_id=1 AND comments&gt;1 ORDER BY views DESC LIMIT 1;</strong></p>
<p>首先建立了一个复合索引，发现索引会失效，不过这至少解决了<strong>全表扫描</strong>的问题。</p>
<p>从<strong>type=range</strong>可以看出，由于 comments 是范围查找，无法精确，即range类型查询后面的索引views无效。试试将comments设置为精确值1，则达到了我们想要的优化效果。</p>
</blockquote>
<p><img src="http://www.caijy.top/image-20210315194449424.png" alt="image-20210315194449424"></p>
<blockquote>
<p>于是就去掉了使用范围查询的这个索引comments</p>
<p><img src="http://www.caijy.top/image-20210315195903780.png" alt="image-20210315195903780"></p>
<p><img src="http://www.caijy.top/image-20210315200003933.png" alt="image-20210315200003933"></p>
<p>发现原来的索引并不能解决问题，所以要将复合索引删除，重新建立一个没有comments的复合索引</p>
<p><img src="http://www.caijy.top/image-20210315200920416.png" alt="image-20210315200920416"></p>
</blockquote>
<h5 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h5><blockquote>
<p>A LEFT JOIN B ON A.id=B.sid</p>
<p>左连接的特性是，LEFT JOIN的条件用于确定如何去搜索右边的行，左表肯定有，关键是搜索右表。</p>
<p>所以，此时应该为B表的sid建立索引。</p>
</blockquote>
<h5 id="JOIN语句的优化"><a href="#JOIN语句的优化" class="headerlink" title="JOIN语句的优化"></a>JOIN语句的优化</h5><h6 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a>小表驱动大表</h6><p>  IN </p>
<blockquote>
<p>SELECT id From A WHERE id IN (SELECT id FROM B)；</p>
<p>Mysql执行这条语句的顺序是，先将B表查出再与A表进行匹配。</p>
<p>如果B的结果集较小，此时小表(B表)驱动大表(A表)，那么IN性能优于EXISTS</p>
</blockquote>
<p>  EXISTS </p>
<blockquote>
<p>SELECT id From A WHERE EXISTS  (SELECT 1 FROM B WHERE A.id=B.id)；</p>
<p>EXISTS(subQuery)返回的是true或者false,可以理解为将主查询的语句放到子查询去做验证，根据验证结果决定主查询的数据结果是否得以保留。B查询的数据量大的情况下，小表(A表)驱动大表(B表)，EXISTS 性能更优。</p>
</blockquote>
<h6 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h6><blockquote>
<p>ORDER BY 避免出现 <code>using file sort</code>，最好有<code>using index</code></p>
</blockquote>
<blockquote>
<p>order by 需遵循最左前缀原则</p>
<p>排序的字段最好都是DESC或者都是ASC</p>
</blockquote>
<h4 id="索引失效常见的原因"><a href="#索引失效常见的原因" class="headerlink" title="索引失效常见的原因"></a>索引失效常见的原因</h4><h5 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h5><p><img src="http://www.caijy.top/image-20210315215235565.png" alt="image-20210315215235565"></p>
<h5 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h5><ul>
<li><p>带头大哥不能死</p>
<blockquote>
<p>SELECT * FROM staffs WHERE age=25; （X)</p>
</blockquote>
</li>
<li><p>中间兄弟不能断</p>
<blockquote>
<p>SELECT * FROM staffs WHERE NAME=’July’ AND pos=’dev’;（X)</p>
</blockquote>
</li>
<li><p>如果建的复合索引都在where条件中精确匹配，可以不在乎顺序，比如复合索引 idx_staffs_nameAgePosAddr</p>
<blockquote>
<p> SELECT * FROM staffs  WHERE age=12 and name=’’ and pos=’’ and addr=’’</p>
<p>mysql内部的查询优化器会先将查询条件按照复合索引建立的顺序来排序</p>
</blockquote>
</li>
</ul>
<h5 id="不要在索引列上做任何操作"><a href="#不要在索引列上做任何操作" class="headerlink" title="不要在索引列上做任何操作"></a>不要在索引列上做任何操作</h5><blockquote>
<p>不要在索引列上做任何操作 (计算、函数、(自动or手动类型转换))，会导致索引失效而转向全表扫描</p>
</blockquote>
<h5 id="范围条件右边的列索引失效"><a href="#范围条件右边的列索引失效" class="headerlink" title="范围条件右边的列索引失效"></a>范围条件右边的列索引失效</h5><blockquote>
<p>存储引擎不能使用索引中范围条件右边的列</p>
</blockquote>
<h5 id="尽量使用覆盖索引"><a href="#尽量使用覆盖索引" class="headerlink" title="尽量使用覆盖索引"></a>尽量使用覆盖索引</h5><blockquote>
<p>尽量使用覆盖索引(只访问索引的查询（索引列和查询列一致）)，减少select *</p>
</blockquote>
<h5 id="！-或者-lt-gt"><a href="#！-或者-lt-gt" class="headerlink" title="！=或者&lt;&gt;"></a>！=或者&lt;&gt;</h5><blockquote>
<p>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
</blockquote>
<h5 id="is-null，is-not-null"><a href="#is-null，is-not-null" class="headerlink" title="is null，is not null"></a>is null，is not null</h5><blockquote>
<p>is null，is not null也无法使用索引</p>
</blockquote>
<h5 id="like以通配符开头"><a href="#like以通配符开头" class="headerlink" title="like以通配符开头"></a>like以通配符开头</h5><blockquote>
<p>like以通配符开头，mysql索引失效 会全表扫描</p>
<p>工作中难免会使用%开头去模糊搜索，这时候可以使用<strong>覆盖索引</strong>解决问题。</p>
<p>覆盖索引规定查询的列必须是索引列。比如idx_name_age_email是NAME、AGE、EMAIL这三个字段的覆盖索引，</p>
<p>那么查询sql是 </p>
<blockquote>
<p>SELECT NAME,AGE,EMAIL FROM USER WHERE NAME LIKE ‘%zhang%’</p>
</blockquote>
</blockquote>
<h5 id="字符串不加单引号"><a href="#字符串不加单引号" class="headerlink" title="字符串不加单引号"></a>字符串不加单引号</h5><blockquote>
<p>字符串不加单引号索引失效</p>
<p>比如 SELECT NAME FROM NAME=2000</p>
<p>如果表里有这条记录会被查询出来，但是这是mysql对NAME列的值做了类型转换，执行的是全表扫描</p>
</blockquote>
<h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><blockquote>
<p>少用or 用它来连接时会索引失效</p>
</blockquote>
<h4 id="排查查询性能"><a href="#排查查询性能" class="headerlink" title="排查查询性能"></a>排查查询性能</h4><blockquote>
<ol>
<li>查看慢查询日志 <code>show variables like &quot;%query%&quot; ;</code></li>
<li>EXPLAIN 分析</li>
<li>如果还无法解决，使用<code>show profile</code>，做更细粒度的分析</li>
<li>数据库参数设置优化</li>
</ol>
</blockquote>
<h4 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h4><blockquote>
<p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于sql的调优测量</p>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</blockquote>
<h6 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h6><blockquote>
<ol>
<li><p>当前mysql版本是否支持 <code>show VARIABLES like &#39;profiling&#39;</code></p>
</li>
<li><p>开启profile功能 <code>set profiling=on</code></p>
</li>
<li><p>运行sql</p>
</li>
<li><p>查看结果 <code>show profiles</code></p>
</li>
<li><p>诊断sql，<code>show profile cpu,block io for query [query_id]</code></p>
</li>
</ol>
<ul>
<li><p>常用的参数 </p>
<p><img src="http://www.caijy.top/image-20210317212701015.png" alt="image-20210317212701015"></p>
</li>
<li><p>执行结果 会显示这条sql的生命周期，如果出现一下四种 要引起重视</p>
<blockquote>
<p>converting HEAP to MyISAM  查询结果太大，内存不够用需要往磁盘里存</p>
<p>Creating tmp table  创建临时表，即先拷贝数据到临时表，用完再删除</p>
<p>Copying to tmp table on disk 把内存中临时表复制到磁盘！</p>
<p>locked 锁表</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="慢查询分析工具mysqldumpslow"><a href="#慢查询分析工具mysqldumpslow" class="headerlink" title="慢查询分析工具mysqldumpslow"></a>慢查询分析工具mysqldumpslow</h4><blockquote>
<p>-s    表示按照何种方式排序</p>
<p>-c    访问次数</p>
<p>-l    锁定时间</p>
<p>-r    返回记录</p>
<p>t    查询时间</p>
<p>-t    返回前多少条的数据</p>
<p>-al    平均锁定时间</p>
<p>-ar    平均返回记录数</p>
<p>-at    平均查询时间</p>
<p>-g    后面搭配正则表达式 大小写不敏感</p>
</blockquote>
<blockquote>
<p>返回记录集最多的 20个sql语句</p>
<p><code>mysqldumpslow -s r -t 20 host-slow.log </code></p>
<p>访问次数最多的 20个sql 语句</p>
<p><code>mysqldumpslow -s c -t 20 host-slow.log</code></p>
<p>按照时间返回前 10 条里面含有left join的 sql 语句。</p>
<p><code>mysqldumpslow -t 10 -s t -g &quot;left join&quot; host-slow.log</code></p>
<p>这会输出记录次数最多的10条SQL语句，</p>
<p><code>mysqldumpslow -s c -t 10 host-slow.log</code></p>
<p>建议使用这些命令时结合<code>|more</code>使用，否则会出现爆屏情况，比如<code>mysqldumpslow -s c -t 10 host-slow.log|more</code></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Phaser</title>
    <url>/posts/67a25c45/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><blockquote>
<p>JDK5中引入了CyclicBarrier和CountDownLatch这两个并发控制类，而JDK7中引入的Phaser按照官方的说法是提供了一个功能类似但是更加灵活的实现。</p>
<p>CyclicBarrier可以被看成一个发令枪，内部有个计数器，初始值为0。每个线程准备就绪后，计数器加一，直到等于设定的目标值。当线程全部就绪后，一起并发执行，类似于百米赛跑。</p>
<p>CountDownLatch类似于下班后最后一个关门的人，等到最后一个人走了才把门关上。即线程全部执行完毕后在main线程中执行接下来的逻辑。</p>
<p>CountDownLatch是一次性的，CyclicBarrier是可复用的。试想一下，如果<strong>一个任务需要分多阶段进行，且每个阶段可以多个线程并发执行</strong>，用CyclicBarrier和CountDownLatch实现就比较复杂了。为了解决这个问题，Phaser就登场了。</p>
<p>Phaser 可以保证每个阶段执行的顺序，即阶段1必须执行完才会执行阶段2。</p>
</blockquote>
<h6 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h6><p>现在我们来讲一个寝室室友一起出去吃饭的例子。这个例子分为起床，穿衣洗漱，吃饭，散步，返回5个阶段。</p>
<span id="more"></span>

<ul>
<li><p>晒代码(假设有3个室友)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] name = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;pA&quot;</span>,<span class="string">&quot;pB&quot;</span>,<span class="string">&quot;pC&quot;</span>&#125;;</span><br><span class="line">   <span class="keyword">public</span>  Phaser phaser = <span class="keyword">new</span> Phaser(name.length)&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;*********阶段&quot;</span>+(phase+<span class="number">1</span>)+<span class="string">&quot;结束！********&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">  </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;起床了！&quot;</span>);</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;穿衣洗漱了！&quot;</span>);</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃饭了！&quot;</span>);</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;散步了！&quot;</span>);</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">&quot;回家了！&quot;</span>);</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           getUp();</span><br><span class="line">           wash();</span><br><span class="line">           eat();</span><br><span class="line">           walk();</span><br><span class="line">           goHome();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@org</span>.junit.Test</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name.length; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(),name[i]).start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行效果</p>
<h6 id><a href="#" class="headerlink" title></a><img src="http://www.caijy.top//20210331162424.png" alt="image-20210331162417798"></h6></li>
<li><p>类的说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent   the parent phaser   父phaser</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parties  the number of parties required to advance to the next phase  	       * 需要到达下一阶段的人数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>status是一个64位的long变量，设计十分巧妙，详见  <a href="http://www.voidcn.com/article/p-hvlsqvuf-bbe.html">Phaser</a>。</p>
<p>这里的源码就省略了，看了这段代码会发现，这个方法的实现用了大量的<strong>位运算</strong>去计算<strong>status</strong>的值，也使用了大量的<strong>CAS</strong>操作。考虑到并发条件下，status这个变量的资源会被大量竞争，CAS系统层面的操作很可能会被重复调用造成大量CPU开销。所以建议使用父Phaser，把对status一部分的计算分担到子Phaser中，父Phaser 只需负责推动每个阶段的进行，提高Phaser的吞吐量。</p>
<h6 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h6><blockquote>
<p><code>bulkRegister(int parties)</code>    批量注册需要协作的线程。</p>
<p><code>arriveAndAwaitAdvance()</code>         线程执行结束。必须等待其他线程</p>
<p><code>onAdvance(int phase, int registeredParties)</code>     每个阶段线程都执行完毕会调用此方法</p>
</blockquote>
</li>
</ul>
<h6 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] name = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;pA&quot;</span>, <span class="string">&quot;pB&quot;</span>, <span class="string">&quot;pC&quot;</span>, <span class="string">&quot;pD&quot;</span>, <span class="string">&quot;pE&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String[] nameX = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;XA&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;XD&quot;</span>, <span class="string">&quot;XE&quot;</span>&#125;;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Phaser parent = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;*******parent***&quot;</span> + phase + <span class="string">&quot;********&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">final</span> Phaser phaser1 = <span class="keyword">new</span> Phaser(parent) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;*******phaser1***&quot;</span> + phase + <span class="string">&quot;********&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="keyword">final</span> Phaser phaser2 = <span class="keyword">new</span> Phaser(parent) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;*******phaser2***&quot;</span> + phase + <span class="string">&quot;********&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       phaser1.bulkRegister(<span class="number">5</span>);</span><br><span class="line">       phaser2.bulkRegister(<span class="number">4</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name.length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> finalI = i;</span><br><span class="line">           Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               System.out.println(name[finalI] + <span class="string">&quot;:&quot;</span> + finalI);</span><br><span class="line">               phaser1.arriveAndAwaitAdvance();</span><br><span class="line">           &#125;);</span><br><span class="line">           t.start();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> finalI = i;</span><br><span class="line">           Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">               System.out.println(nameX[finalI] + <span class="string">&quot;:&quot;</span> + finalI);</span><br><span class="line">               phaser2.arriveAndAwaitAdvance();</span><br><span class="line">           &#125;);</span><br><span class="line">           t.start();</span><br><span class="line">       &#125;</span><br><span class="line">       parent.awaitAdvance(parent.getPhase());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="-1"><a href="#-1" class="headerlink" title></a><img src="http://www.caijy.top//20210331165607.png" alt="image-20210331165607204"></h5><p>参考</p>
<ol>
<li> <a href="http://www.voidcn.com/article/p-hvlsqvuf-bbe.html">Phaser使用和解析</a></li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
        <category>Phaser</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>spring实例化bean的过程探索(上)</title>
    <url>/posts/1e622231/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li><p>采用注解方式或者XML方式，这里使用的是注解方式</p>
</li>
<li><p>创建一个简单的全局配置类，指定包扫描路径即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.debug.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.debug&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在扫描路径下创建一个class </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.debug.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;TestBean created ...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义一个测试类Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.debug.bean.TestBean;</span><br><span class="line"><span class="keyword">import</span> com.debug.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCrateBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">		TestBean bean = applicationContext.getBean(TestBean.class);<span class="comment">//比较常用的getBean方法</span></span><br><span class="line">		log.info(bean.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行结果</p>
<img src="https://www.caijy.top//%E6%88%AA%E5%B1%8F2021-07-26%20%E4%B8%8B%E5%8D%881.02.38.png" alt="截屏2021-07-26 下午1.02.38" style="zoom:50%;"></li>
</ul>
<span id="more"></span>

<h1 id="探索开始"><a href="#探索开始" class="headerlink" title="探索开始"></a>探索开始</h1><h2 id="第一次调试"><a href="#第一次调试" class="headerlink" title="第一次调试"></a>第一次调试</h2><p><img src="https://www.caijy.top//spring%E5%88%9B%E5%BB%BAbean%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%951.gif" alt="spring创建bean源码调试1"></p>
<ol>
<li>经过第一波调试后发现重点在<code>DefaultListableBeanFactory</code>提供的<code>resolveNamedBean</code>,这里面包含了获取bean的步骤</li>
</ol>
<h2 id="第二次调试"><a href="#第二次调试" class="headerlink" title="第二次调试"></a>第二次调试</h2><p><img src="https://www.caijy.top//spring%E5%88%9B%E5%BB%BAbean%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%952.gif" alt="spring创建bean源码调试2"></p>
<ol start="2">
<li>第二次调试也有了进展，最终定位在了<code>AbstractBeanFactory</code>的<code>getBean</code>方法</li>
</ol>
<h2 id="第三次调试"><a href="#第三次调试" class="headerlink" title="第三次调试"></a>第三次调试</h2><p><img src="https://www.caijy.top//spring%E5%88%9B%E5%BB%BAbean%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%953.gif" alt="spring创建bean源码调试3"></p>
<ol start="3">
<li>第三次调试发现bean是从单例池中取的<ul>
<li>这说明容器对象<code>AnnotationConfigApplicationContext</code>初始化的时候，就已经将<code>testBean</code>实例化放在了<code>singletonObjects</code>中。</li>
<li>那么<code>testBean</code>是怎么实例化的呢？这需要继续调试<code>AnnotationConfigApplicationContext</code>初始化的代码了。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>spring 5.1.X源码</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>给博客选择主题</title>
    <url>/posts/816f907b/</url>
    <content><![CDATA[<h4 id="给博客选择主题，拿流行的NEXT主题为例。"><a href="#给博客选择主题，拿流行的NEXT主题为例。" class="headerlink" title="给博客选择主题，拿流行的NEXT主题为例。"></a>给博客选择主题，拿流行的NEXT主题为例。</h4><p>1.初始化一个博客，文件夹命名为<em>hexo-site</em><code>hexo init hexo-site</code><br>2.下载源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/next-theme/theme-next-docs</span></span><br><span class="line">cd theme-next-docs</span><br><span class="line">npm install</span><br><span class="line">cd hexo-site\themes</span><br><span class="line">npm install hexo-theme-next</span><br><span class="line">npm install hexo-theme-next@latest #如果要更新主题用这个命令</span><br><span class="line">hexo generate</span><br><span class="line">hexo clean </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h4 id="给我们的博客添加看板娘"><a href="#给我们的博客添加看板娘" class="headerlink" title="给我们的博客添加看板娘"></a>给我们的博客添加看板娘</h4><p>1.下载看板娘，先进入到Hexo博客根目录<br><code>npm install --save hexo-helper-live2d</code><br>或 <code>cnpm install --save hexo-helper-live2d</code></p>
<span id="more"></span>
<p>2.选择模块<br><code>npm install [模块名]</code><br>可选择的模块如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2D模型全名称：</span><br><span class="line">            live2d-widget-model-haruto      小娃娃（男）</span><br><span class="line">            live2d-widget-model-koharu      小娃娃（女）</span><br><span class="line">            live2d-widget-model-ni-j        小娃娃（不知道怎么描述，带这个耳机）</span><br><span class="line">            live2d-widget-model-nico        小娃娃（狐狸？？）</span><br><span class="line">            live2d-widget-model-nipsilon    小娃娃（粉长头发小娃娃）</span><br><span class="line">            live2d-widget-model-nito        小娃娃（粉短头发小娃娃）</span><br><span class="line">            live2d-widget-model-unitychan   小娃娃（黄色长头发小娃娃）</span><br><span class="line">            live2d-widget-model-chitose     一个帅哥</span><br><span class="line">            live2d-widget-model-shizuku     坐在课桌上的小美女</span><br><span class="line">            live2d-widget-model-hibiki      一个小妹妹</span><br><span class="line">            live2d-widget-model-izumi       一个妹子</span><br><span class="line">            live2d-widget-model-tsumiki     绿萝？？？？</span><br><span class="line">            live2d-widget-model-miku        初音</span><br><span class="line">            live2d-widget-model-z16         这个妹子好看</span><br><span class="line">            live2d-widget-model-hijiki      黑猫</span><br><span class="line">            live2d-widget-model-tororo      白猫</span><br><span class="line">            live2d-widget-model-wanko       趴在碗里的狗</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E7%BB%99%E5%8D%9A%E5%AE%A2%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98/1.png"><br>看到执行有类似的报错可以忽略。</p>
<p>3.可以看到<code>node_modules</code>里面已经有了2个文件夹<br><img src="/images/%E7%BB%99%E5%8D%9A%E5%AE%A2%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98/2.png"></p>
<p>4.修改<code>_config.yml</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  # enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: 0</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放       </span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure>
<p>注意：<code>live2d.model.use</code>的值跟你选的模块文件夹名称要对应上，比如这里是<code>live2d-widget-model-wanko</code><br>5.执行<code>hexo clean</code>和<code>hexo g</code><br>6.执行<code>hexo s</code>看效果<br><img src="/images/%E7%BB%99%E5%8D%9A%E5%AE%A2%E9%80%89%E6%8B%A9%E4%B8%BB%E9%A2%98/3.png"></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>博客设置</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/posts/587418e1/</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote>
<p>什么是事务？</p>
</blockquote>
<p>要么都成功，要么都失败。</p>
<h4 id="ACID原则"><a href="#ACID原则" class="headerlink" title="ACID原则"></a>ACID原则</h4><blockquote>
<p>关系型数据库支持事务的 ACID 原则，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p>
</blockquote>
<h5 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h5><p>要么都成功，要么都失败。主要由<code>undolog</code>决定。</p>
<h5 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h5><p>一致性是指在事务开始之前和事务结束以后，数据完整性要保持一致。由其他三大特性共同决定。</p>
<p>比如A给B转账，事务前后A和B的总金额是一样的，这就是最终一致性。</p>
<h5 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h5><p>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不会被其他事务的操作数据所干扰。主要是由MVCC机制来决定。</p>
<h5 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h5><p>事务一旦提交则不可逆，被持久化到数据库中。主要是由<code>redolog</code>和<code>binlog</code>来决定。</p>
<h5 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h5><blockquote>
<p><strong>三大日志<code>undolog</code>、<code>redolog</code>、<code>binlog</code>的主要作用。</strong></p>
<p><strong><code>undolog</code>用于事务的回滚，保证事务的原子性</strong></p>
<p><strong><code>redolog</code>会在事务提交前后进行2阶段提交，实现<code>MySQL</code>实例宕机后未提交数据的持久化，因此这让<code>MySQL</code>拥有了崩溃恢复能力。</strong></p>
<p>更具体的可以查看<a href="https://javaguide.cn/database/mysql/mysql-logs.html#%E5%89%8D%E8%A8%80">三大日志详解</a>。</p>
</blockquote>
<h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><blockquote>
<p>在并发环境下，多个事务在执行操作，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
</blockquote>
<span id="more"></span>
<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><blockquote>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">张三的工资为<span class="number">5000</span>,事务A中把他的工资改为<span class="number">8000</span>,但事务A尚未提交。</span><br><span class="line">与此同时，</span><br><span class="line">事务B正在读取张三的工资，读取到张三的工资为<span class="number">8000</span>。</span><br><span class="line">随后，</span><br><span class="line">事务A发生异常，而回滚了事务。张三的工资又回滚为<span class="number">5000</span>。</span><br><span class="line">最后，</span><br><span class="line">事务B读取到的张三工资为<span class="number">8000</span>的数据即为脏数据，事务B做了一次脏读。</span><br></pre></td></tr></table></figure>

<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><blockquote>
<p>事务读取数据后，另一个事务新增或删除了一条记录，导致查询出来的结果跟前一次不一样。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">目前工资为<span class="number">5000</span>的员工有<span class="number">10</span>人，事务A读取所有工资为<span class="number">5000</span>的人数为<span class="number">10</span>人。</span><br><span class="line">此时，</span><br><span class="line">事务B插入一条工资也为<span class="number">5000</span>的记录。</span><br><span class="line">这是，事务A再次读取工资为<span class="number">5000</span>的员工，记录为<span class="number">11</span>人。此时产生了幻读。</span><br></pre></td></tr></table></figure>

<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><blockquote>
<p>一个事务多次读同一个数据，中间另一个事务提交并修改了数据，会造成多次读到的数据不一样。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">在事务A中，读取到张三的工资为<span class="number">5000</span>，操作没有完成，事务还没提交。</span><br><span class="line">与此同时，</span><br><span class="line">事务B把张三的工资改为<span class="number">8000</span>，并提交了事务。</span><br><span class="line">随后，</span><br><span class="line">在事务A中，再次读取张三的工资，此时工资变为<span class="number">8000</span>。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>**虽然都是读取了未提交的数据，但脏读的重点是修改，幻读的重点在于新增或者删除；而不可重复读是读取了另一个事务已提交的数据，看着没错但是事务不应该互相影响 **</p>
<h5 id="第一类丢失更新"><a href="#第一类丢失更新" class="headerlink" title="第一类丢失更新"></a>第一类丢失更新</h5><blockquote>
<p>A和B访问修改同一个数据，A事务撤消时，把已提交的B事务的数据覆盖掉</p>
</blockquote>
<h5 id="第二类丢失更新"><a href="#第二类丢失更新" class="headerlink" title="第二类丢失更新"></a>第二类丢失更新</h5><blockquote>
<p>A和B访问修改同一个数据，A事务提交时，把已提交的B事务的数据覆盖掉</p>
</blockquote>
<h4 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h4><blockquote>
<p>封锁就是事务T在对某个数据对象（例如表记录等）操作前先向系统发起请求，对其加锁。</p>
<p>在事务T释放锁之前，其他事务不能更新此数据对象。</p>
<p>封锁是实现并发控制的一个非常重要的技术。</p>
</blockquote>
<h5 id="基本封锁类型"><a href="#基本封锁类型" class="headerlink" title="基本封锁类型"></a>基本封锁类型</h5><h6 id="排他锁-X锁-写锁"><a href="#排他锁-X锁-写锁" class="headerlink" title="排他锁(X锁/写锁)"></a>排他锁(X锁/写锁)</h6><blockquote>
<p>INNODB中锁的概念。释放锁之前，其他事务不能读取和修改加锁的数据</p>
</blockquote>
<h6 id="共享锁-S锁-读锁"><a href="#共享锁-S锁-读锁" class="headerlink" title="共享锁(S锁/读锁)"></a>共享锁(S锁/读锁)</h6><blockquote>
<p>INNODB中锁的概念。释放锁之前，其他事务可以读取但不能修改加锁的数据</p>
</blockquote>
<h6 id="锁的相容性"><a href="#锁的相容性" class="headerlink" title="锁的相容性"></a>锁的相容性</h6><table>
<thead>
<tr>
<th>-</th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>S</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h6 id="扩展和补充"><a href="#扩展和补充" class="headerlink" title="扩展和补充"></a>扩展和补充</h6><blockquote>
<h4 id="表锁-偏读"><a href="#表锁-偏读" class="headerlink" title="表锁(偏读)"></a>表锁(偏读)</h4><h6 id="由于MYISAM只支持表锁，INNODB支持表锁和行锁。所以MYISAM和INNODB中表锁的情况都一致。"><a href="#由于MYISAM只支持表锁，INNODB支持表锁和行锁。所以MYISAM和INNODB中表锁的情况都一致。" class="headerlink" title="由于MYISAM只支持表锁，INNODB支持表锁和行锁。所以MYISAM和INNODB中表锁的情况都一致。"></a>由于MYISAM只支持表锁，INNODB支持表锁和行锁。所以MYISAM和INNODB中表锁的情况都一致。</h6><p>查看加锁的表：<code>show open tables</code></p>
<p>加锁命令：<code>lock table [表名][read/write]</code></p>
<p>释放锁命令：<code>unlock tables</code></p>
<p>如何分析表锁</p>
<ul>
<li><blockquote>
<p>执行<code>show status like &#39;table%&#39;</code></p>
<p>查看``Table_locks_waited`  ，表示产生锁争用而发生等待的次数，没等待一次锁值加1。值越高说明表锁争用情况严重。</p>
</blockquote>
</li>
</ul>
<h5 id="会话1给A表加写锁，则只能读和写A表，不能读其他未加读锁的表。会话2不能读到A表，会一直阻塞，直到A表的写锁释放。"><a href="#会话1给A表加写锁，则只能读和写A表，不能读其他未加读锁的表。会话2不能读到A表，会一直阻塞，直到A表的写锁释放。" class="headerlink" title="会话1给A表加写锁，则只能读和写A表，不能读其他未加读锁的表。会话2不能读到A表，会一直阻塞，直到A表的写锁释放。"></a>会话1给A表加写锁，则只能读和写A表，不能读其他未加读锁的表。会话2不能读到A表，会一直阻塞，直到A表的写锁释放。</h5><h5 id="会话1给A表加读锁，则只能读A表，不能读其他未加读锁的表，且不能修改A表。会话2可以读到A表，但是更新A表时会一直阻塞，直到A表的读锁释放。"><a href="#会话1给A表加读锁，则只能读A表，不能读其他未加读锁的表，且不能修改A表。会话2可以读到A表，但是更新A表时会一直阻塞，直到A表的读锁释放。" class="headerlink" title="会话1给A表加读锁，则只能读A表，不能读其他未加读锁的表，且不能修改A表。会话2可以读到A表，但是更新A表时会一直阻塞，直到A表的读锁释放。"></a>会话1给A表加读锁，则只能读A表，不能读其他未加读锁的表，且不能修改A表。会话2可以读到A表，但是更新A表时会一直阻塞，直到A表的读锁释放。</h5><h3 id="行锁-偏写"><a href="#行锁-偏写" class="headerlink" title="行锁(偏写)"></a>行锁(偏写)</h3><p>行锁的特点是：</p>
<ul>
<li>开销大、加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
<h5 id="INNODB与MYISAM最大不同有2点：支持事务和采用行级锁"><a href="#INNODB与MYISAM最大不同有2点：支持事务和采用行级锁" class="headerlink" title="INNODB与MYISAM最大不同有2点：支持事务和采用行级锁"></a>INNODB与MYISAM最大不同有2点：<code>支持事务</code>和<code>采用行级锁</code></h5><p>可以看出，行锁是支持事务的。</p>
<h5 id="如何手动锁定一行"><a href="#如何手动锁定一行" class="headerlink" title="如何手动锁定一行"></a>如何手动锁定一行</h5><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">...... for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>此时其他会话要修改这行的数据，会发生阻塞，直到<code>commit</code></p>
</blockquote>
<h5 id="什么情况下行锁变表锁？"><a href="#什么情况下行锁变表锁？" class="headerlink" title="什么情况下行锁变表锁？"></a>什么情况下行锁变表锁？</h5><p>比如（演示前要先<code>set autocommit=0;</code>）： </p>
<p>会话1<code>update A set NAME=100 where ID=1; </code> NAME <code>VARCHAR</code> 类型没有使用单引号.</p>
<p>会话2 <code>select * from A where ID=1 </code>。此时由于会话1内部产生了自动类型转换造成<strong>索引失效</strong>，导致表锁。如果会话1不<code>commit</code>会一直阻塞。</p>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><blockquote>
<p>演示前要先<code>set autocommit=0;</code>。</p>
</blockquote>
<blockquote>
<p>会话1：<code>select * from A where id &gt;1 and id &lt;8。</code> 假设A表没有id=6的记录。</p>
</blockquote>
<blockquote>
<p>会话2： <code>insert into A values (6，.....)</code>。此时插入id=6的记录，会发生阻塞。即发生了间隙锁。</p>
</blockquote>
<blockquote>
<h5 id="当我们用范围条件检索数据，并请求共享锁或排他锁时，Innodb会给符合条件的已有数据记录的索引项加锁。在范围条件内但并不存在的记录，叫做“间隙”。Innodb也会对间隙加锁。在某种场景下间隙锁造成的阻塞，会对性能造成很大影响。"><a href="#当我们用范围条件检索数据，并请求共享锁或排他锁时，Innodb会给符合条件的已有数据记录的索引项加锁。在范围条件内但并不存在的记录，叫做“间隙”。Innodb也会对间隙加锁。在某种场景下间隙锁造成的阻塞，会对性能造成很大影响。" class="headerlink" title="当我们用范围条件检索数据，并请求共享锁或排他锁时，Innodb会给符合条件的已有数据记录的索引项加锁。在范围条件内但并不存在的记录，叫做“间隙”。Innodb也会对间隙加锁。在某种场景下间隙锁造成的阻塞，会对性能造成很大影响。"></a>当我们用范围条件检索数据，并请求共享锁或排他锁时，<code>Innodb</code>会给符合条件的已有数据记录的索引项加锁。在范围条件内但并不存在的记录，叫做“间隙”。<code>Innodb</code>也会对间隙加锁。在某种场景下间隙锁造成的阻塞，会对性能造成很大影响。</h5></blockquote>
<h4 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key-Lock"></a>Next-key-Lock</h4><blockquote>
<p>临键锁，锁定一个范围，包含记录本身</p>
</blockquote>
</blockquote>
<h5 id="封锁协议之三级封锁协议"><a href="#封锁协议之三级封锁协议" class="headerlink" title="封锁协议之三级封锁协议"></a>封锁协议之三级封锁协议</h5><blockquote>
<p>解决了并发一致性问题。</p>
</blockquote>
<h6 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h6><blockquote>
<p>事务在修改数据之前必须对数据加<strong>X锁</strong>，直到释放锁</p>
</blockquote>
<ol>
<li> 一级封锁协议可防止丢失修改，并保证事务T是可恢复的</li>
<li> 读数据不需要加读锁，不能解决不可重复读和脏读问题</li>
</ol>
<h6 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h6><blockquote>
<p>在一级封锁协议基础上，在读取数据前要加读锁，读完后即释放锁</p>
</blockquote>
<ol>
<li>可以防止丢失修改和脏读</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81.png"></p>
<h6 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h6><blockquote>
<p>在一级封锁协议基础上，读取数据要加读锁，直到事务结束才释放</p>
</blockquote>
<ol>
<li>三级封锁协议可防止丢失修改、脏读和不可重复读</li>
</ol>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81.png"></p>
<h6 id="三种协议的对比"><a href="#三种协议的对比" class="headerlink" title="三种协议的对比"></a>三种协议的对比</h6><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%89%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94.png"></p>
<h5 id="封锁协议之两段锁协议"><a href="#封锁协议之两段锁协议" class="headerlink" title="封锁协议之两段锁协议"></a>封锁协议之两段锁协议</h5><blockquote>
<p>加锁和解锁阶分为两个阶段进行。</p>
<p>内容：</p>
<ol>
<li>在对任何数据进行读写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再获得其他封锁</li>
</ol>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<p>lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B)</p>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p>
<p>lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C)</p>
</blockquote>
<h5 id="封锁带来的问题"><a href="#封锁带来的问题" class="headerlink" title="封锁带来的问题"></a>封锁带来的问题</h5><h6 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h6><blockquote>
<p>系统可能是某个事务永远处于等待状态，得不到封锁的机会</p>
</blockquote>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%B4%BB%E9%94%81.png"></p>
<p>如何避免？先来先服务策略</p>
<h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%AD%BB%E9%94%81.png"></p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><blockquote>
<p>为了解决上述问题，数据库通过<strong>锁机制</strong>解决并发访问的问题。根据锁定对象不同：分为行级锁和表级锁；根据并发事务锁定的关系上看：分为共享锁和排它锁，共享锁会防止排它锁但允许其他的共享锁。而排它锁既防止共享锁也防止其他排它锁。为了更改数据，数据库必须在进行更改的行上施加行排它锁，insert、update、delete和select for update语句都会隐式采用必要的行锁定。</p>
<p>但是直接使用锁机制管理是很复杂的，基于锁机制，数据库给用户提供了不同的<strong>事务隔离级别</strong>，只要设置了事务隔离级别，数据库就会分析事务中的sql语句然后自动选择合适的锁。 </p>
</blockquote>
<h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a><strong>读未提交</strong></h5><blockquote>
<p>读未提交(READ_UNCOMMITTED)，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用</p>
</blockquote>
<h5 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a><strong>读已提交</strong></h5><blockquote>
<p>读已提交(READ_COMMITED)，即能够读到那些已经提交的数据，能够防止脏读，但是无法限制不可重复读和幻读</p>
</blockquote>
<h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a><strong>可重复读</strong></h5><blockquote>
<p>可重复读(REPEATABLE_READ)，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决</p>
</blockquote>
<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a><strong>串行化</strong></h5><blockquote>
<p>串行化(SERLALIZABLE)，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务。比如幻读，事务A的插入或删除操作必须等待事务B的事务结束后才会进行，否则会一直阻塞。这样就解决了脏读、不可重复读和幻读的问题了。但缺点是性能十分低下。</p>
</blockquote>
<p>不同数据库默认的隔离级别是不同的。mysql支持四种隔离级别,默认隔离级别是<code>REPEATABLE_READ</code>,oracle支持<code>READ_COMMITED</code>和<code>SERLALIZABLE</code>,默认隔离级别是<code>READ_COMMITED</code>。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><blockquote>
<p>多版本并发控制(Multi-Version Concurrentcy control)的简称，针对读已提交和可重复读</p>
<p>通过记录多个修改的历史版本替代锁，实现事务间的隔离效果，保证非阻塞读！</p>
<p>实现核心为三点</p>
<ul>
<li>表的隐藏列：记录事务ID及上个版本数据地址，即事务ID <strong>trix_id</strong>和回滚指针<strong>roll_pointer</strong></li>
<li>undo log: 记录数据各版本修改历史即事务链，生成undo日志的时候会带上隐藏列</li>
<li>read view: 读视图，用于判断哪些版本可见</li>
</ul>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#readview">InnoDB存储引擎对MVCC的实现</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
